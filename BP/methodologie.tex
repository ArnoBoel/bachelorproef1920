%%=============================================================================
%% Methodologie
%%=============================================================================

\chapter{\IfLanguageName{dutch}{Methodologie}{Methodology}}
\label{ch:methodologie}

%% TODO: Hoe ben je te werk gegaan? Verdeel je onderzoek in grote fasen, en
%% licht in elke fase toe welke stappen je gevolgd hebt. Verantwoord waarom je
%% op deze manier te werk gegaan bent. Je moet kunnen aantonen dat je de best
%% mogelijke manier toegepast hebt om een antwoord te vinden op de
%% onderzoeksvraag.

In de vorige hoofdstukken werden de frameworks die in deze studie vergeleken zullen worden geselecteerd en hun achtergrond besproken. In dit hoofdstuk wordt de effectieve vergelijking tussen de verschillende frameworks gemaakt. Verschillende belangrijke onderdelen van mobiele applicatieontwikkeling komen aan bod tijdens de vergelijking. Voor elk framework wordt eerst de aanpak op dit specifieke punt uitgelegd en vervolgens worden beide aanpakken met elkaar vergeleken. In deze vergelijking worden enkel React Native en Flutter met elkaar vergeleken, gezien er nog geen technische aspecten van .NET MAUI gekend zijn op het moment van schrijven.

\section{Taal framework}
\label{subsec:taalFramework}

Elk framework maakt gebruik van een bepaalde taal om een applicatie te ontwikkelen. De taal van een framework is zeer belangrijk, aangezien het zowel de sterke als minder sterke eigenschappen van een taal erft. Een framework met een taal die traag is vergeleken met andere talen of die zeer ingewikkeld is om te leren zal automatisch een minder goede keuze zijn. Het is dus zeer belangrijk van beide talen te vergelijken.

\subsection{React Native}
\label{subsubsec:taalReactNative}

Zoals in sectie \ref{subsec:ReactNative} reeds besproken werd is React Native gebaseerd op React, dat op zijn beurt gebaseerd is op JavaScript. JavaScript is de meest gebruikte taal onder ontwikkelaars wereldwijd \autocite{Liu2020a}. Het is een lichtgewicht taal die weinig eisen stelt aan de hardware van het systeem. Het wordt vooral gebruikt voor de ontwikkeling van webpagina's, maar ook vele andere omgevingen werken met JavaScript zoals o.a. Node.js. JavaScript bestaat al sinds 1995 en is dus een zeer volwassen en stabiele programmeertaal.

Een zeer groot voordeel van JavaScript komt rechtstreeks voort uit het feit dat het al lang bestaat en dat het zeer populair is: er zijn zeer veel libraries en documentatie beschikbaar die het ontwikkelen van een applicatie sterk vereenvoudigen.

Tot slot brengt de React basis nog een zeer groot voordeel met zich mee: de 'hot reload'. React maakt gebruik van een virtual DOM, die een vereenvoudigde beschrijving van de werkelijke DOM bijhoudt. Het aanpassen van de DOM is een traag en intensief proces, het aanpassen van de virtual DOM is echter zeer snel aangezien er niks getoond moet worden op het scherm hiervan. Bij het renderen van een element wordt een snapshot genomen van de virtual DOM die de huidige toestand van de virtual DOM bij houdt. Vervolgens wordt elk object in de virtual DOM geüpdatet. Dit lijkt een intensieve operatie, maar door dat de virtual DOM zo snel geüpdatet kan worden is het dit niet. Nu zijn er dus twee versies van de virtual DOM, één van voor de update en één van erna. Beide versies worden met elkaar vergeleken om vast te stellen wat er exact is veranderd. Enkel de componenten die door de update aangepast zijn worden uiteindelijk in de echte DOM ook aangepast. Door deze werkwijze moet er slechts een deel van de DOM opnieuw gerenderd worden. Dit levert een grote tijdswinst op en stelt React in staat om een 'hot reload' functie te hebben. Dit houdt in dat de UI direct geüpdatet kan worden als de ontwikkelaar aanpassingen opslaat, zonder dat de applicatie opnieuw gebuild moet worden. Er moet dus niet telkens op een nieuwe build gewacht worden, wat bij native ontwikkeling wel het geval is en minutenlang kan duren. Deze functionaliteit levert dus een grote tijdswinst op tijdens het ontwikkelen!

\subsection{Flutter}
\label{subsubsec:taalFlutter}

De taal waarin Flutter applicaties geschreven worden, Dart, kwam al kort aan bod in sectie \ref{subsec:Flutter}. Het is ontwikkeld door Google in 2011 maar is pas in gebruik genomen buiten Google in 2017, toen Google Flutter uitbracht. Het is een client-side programmeertaal die geoptimaliseerd is voor het maken van UI's. Door dat het nog vrij recent is zijn er wel maar een beperkt aantal libraries beschikbaar en moet de ontwikkelaar dus soms meer werk verrichten om bepaalde zaken zelf te gaan schrijven. Verder is de documentatie soms ook onvolledig en is er door de beperkte groep gebruikers slechts weinig ondersteuning van de community.

Er zijn natuurlijk ook zeker enkele positieve eigenschappen aan Dart. Zo lijkt de syntax zeer hard op Java en kan een ontwikkelaar die hier ervaring mee heeft dus ook zeer snel aan de slag met Dart. 

Een ander voordeel is dat Dart zowel naar JavaScript als naar native machine code gecompileerd kan worden. Naar JavaScript is handig voor het ontwikkelen van een webapplicatie, omdat JavaScript een brede ondersteuning heeft in de meeste browsers die Dart niet heeft. Voor het ontwikkelen van mobiele applicaties met Flutter is het echter zeer handig dat het gecompileerd kan worden naar machine code. Op deze manier worden prestaties van de applicatie bereikt die gelijk zijn aan die van een native applicatie, ondanks de cross-platform ontwikkeling er van!

Een laatste sterke eigenschap van Flutter is de 'hot reload' functie. Deze laat toe om aanpassingen in de code (zoals updates in de UI, bug fixes of zelfs hele nieuwe features) toe te passen op de applicatie zonder deze te moeten stoppen en opnieuw builden. Voor zowel het ontwikkelen van de UI als het oplossen van problemen is dit een zeer krachtige eigenschap die de ontwikkelingstijd dratisch verlaagd. De werkwijze steunt op het bestaan van de Dart Virtual Machine. Dit is een VM waar de Dart code in draait en die er voor zorgt dat de code wordt omgezet naar de gewenste taal (machine code of JavaScript). De bron code bestanden die geüpdatet zijn worden in deze VM geïnjecteerd en vervangen de oudere versie van deze bestanden. Vervolgens wordt de hele widget tree opnieuw opgebouwd, waardoor de aanpassingen getoond worden zonder dat de applicatie gestopt moest worden.

\subsection{Vergelijking talen frameworks}
\label{subsubse:vglTalen}

Zoals in de vorige secties duidelijk werd steunen de twee frameworks op een andere taal. In deze sectie worden de verschillen en gelijkinissen tussen beide talen besproken.

Eerst en vooral moet er op gemerkt worden dat beide talen dezelfde achtergrond hebben. Ze zijn beide gestart als een taal voor webomgevingen en zijn daarna verder geëvolueerd om er meerdere soorten applicaties mee te kunnen schrijven. Zo worden ze nu beide gebruikt voor de ontwikkeling van cross-platform applicaties. Een groot verschil tussen de twee is echter dat JavaScript reeds lang bestaat en dat Dart slechts zeer recent publiek gemaakt werd. Hierdoor is er meer ondersteuning voor JavaScript dan voor Dart en zijn er voor JavaScript veel meer libraries beschikbaar.

Een ander groot verschil is de syntax van de talen. JavaScript heeft een syntax die voor beginnende programmeurs soms moeilijk kan zijn. De syntax van Dart leunt zeer dicht aan bij deze van Java, die een stuk eenvoudiger is om te leren. Beginnende programmeurs kunnen dus sneller aan de slag met Flutter dan met React Native. Volgens \textcite{Liu2020a} is JavaScript echter de meest populaire programmeertaal ter wereld, met 67,7\% van de ondervraagden die aangaven JavaScript te gebruiken. Dart werd echter maar door 4\% van de ondervraagden gebruikt! Vele ontwikkelaars hebben dus reeds een kennis van JavaScript en kunnen sneller aan de slag met React Native dan met Flutter.

Flutter heeft een voordeel ten opzichte van React als het aankomt op de prestaties  van de applicatie doordat de code gecompileerd kan worden naar native machine code. JavaScript kan niet omgezet worden naar native machine code, waardoor React Native gebruik moet maken van een brug tussen JavaScript en de native machine code om te werken op een specifiek platform. Dit levert extra overhead op, wat er voor zorgt dat de prestaties verminderen. 

Een gelijkenis tussen de twee frameworks is de hot reload functionaliteit. Ze stellen beiden de ontwikkelaar in staat om aanpassingen zeer snel te kunnen weergeven zonder dat de applicatie heropgestart hoeft te worden. Er bestaat wel een verschil in aanpak tussen de twee. Bij React Native wordt er gebruikt gemaakt van een virtual DOM om de staat van de UI voor en na de de update bij te houden, zodat enkel de aangepaste componenten opnieuw hoeven gerenderd te worden. Bij Flutter wordt er gebruikt gemaakt van een VM, die de aanpassingen injecteert in de broncode en deze doorgeeft aan de applicatie, waarna de widget tree opnieuw opgebouwd wordt. Als ontwikkelaar is er dus bij beide frameworks een grote tijdsbesparing in vergelijking met native ontwikkeling. 



\section{Navigatie binnen de applicatie}
\label{subsec:navigatieApplicatie}

Een belangrijk deel van elke applicatie is de mogelijkheid om te kunnen navigeren tussen verschillende pagina's van de applicatie. Elk cross-platform framework moet dus de mogelijkheid voorzien om de ontwikkelaar toe te staan deze functionaliteit te verwerken in de applicatie.

\subsection{React Native}
\label{subsubsec:navigatieReactNative}

React Native maakt voor de navigatie tussen de verschillende pagina's gebruik van een library genaamd React Native Navigation. Dit is een standalone library die de ontwikkelaar in staat stelt om zowel op Android als iOS navigatie aan te leveren die een native uitstraling heeft. Het is één van de vele populaire libraries binnen React Native die ontwikkeld zijn door de uitgebreide community achter React Native. Onderliggend maakt deze library ook gebruik van een andere library genaamd Animated om de animaties tijdens het navigeren naar een andere pagina aan te bieden. De animaties en gebaren die gepaard gaan met het navigeren kunnen volledig aangepast worden aan de voorkeuren van de ontwikkelaar. Er is dus zeer veel vrijheid en de gebruiker krijgt een applicatie die navigeert zoals een native applicatie. 

Om de navigatie te gebruiken moet de ontwikkelaar de hele applicatie wrappen in een navigatiecontainer. Op deze manier heeft de library toegang tot de gehele applicatie en kan de ontwikkelaar de navigatie tussen de verschillende pagina's instellen naar wens. De werkwijze om de applicatie te wrappen met de navigatiecontainer en de verschillende pagina's toe te voegen aan de navigatiestack is te zien in figuur \ref{fig:opzettenNavigatieReactNative}.

\begin{figure}
    \includegraphics[width=\linewidth]{OpzettenNavigatieReactNative.png}
    \caption{Opzetten navigatie in een React Native applicatie. Bron: reactnative.dev/docs/navigation}
    \label{fig:opzettenNavigatieReactNative}
\end{figure}

Vervolgens moet er vastgelegd worden naar welke pagina er genavigeerd moet worden bij de uitvoering van een bepaald actie, zoals bv de klik op een bepaalde knop. Om dit mogelijk te maken krijgt elke component die een pagina voorstelt een attribuut navigation mee. In dit attribuut zitten methodes van de library die het navigeren tussen de verschillende pagina's mogelijk maakt. De opzet van een simpele navigatie is te zien in figuur \ref{fig:navigerenReactNative}. 

Zoals eerder vermeld heeft de library zeer veel mogelijkheden en levert het een navigatie af die native aanvoelt voor de gebruiker. Om dit te bereiken beschikt React Native Navigation ook over verschillende packages die o.a. tabs en drawer functionaliteit aanbieden. Dit zijn twee populaire manieren om te navigeren binnen een applicatie. Door dit aan te bieden in een package moet de ontwikkelaar niet helemaal zelf deze functionaliteit gaan uitwerken en wordt de standaard die de gebruiker gewoon is van native applicaties geëvenaard.

\begin{figure}
    \includegraphics[width=\linewidth]{NavigerenPaginasReactNative.png}
    \caption{Navigeren naar een andere pagina in React Native. Bron: reactnative.dev/docs/navigation}
    \label{fig:navigerenReactNative}
\end{figure}

\subsection{Flutter}
\label{subsubsec:navigatieFlutter}

Flutter maakt voor de navigatie binnen een applicatie gebruik van de klasse Navigator. Deze klasse op zich is ook een widget, de bouwstenen van een applicatie in Flutter. De verschillende pagina's en schermen van een applicatie worden routes genoemd. Deze routes worden op een stack geplaatst, die de volgorde van de routes bijhoudt. Er zijn twee verschillende aanpakken van navigatie binnen Flutter: de ene is gebaseerd op een vaste volgorde waar alle schermen elkaar opvolgen en de andere laat de ontwikkelaar toe om op aangepaste wijze te navigeren tussen verschillende pagina's. Beide aanpakken worden in de volgende paragrafen verder besproken. 

De eerste aanpak laat de gebruiker toe om in een vaste volgorde door de applicatie te navigeren. Dit is voornamelijk belangrijk als de gebruiker terug wil gaan naar het vorige scherm. In dit geval is het alleen maar logisch om naar de vorige route in de stack te gaan. Het is ook meteen de meest eenvoudige vorm van navigatie. Als de gebruiker naar een andere pagina navigeert wordt deze bovenaan de stack geplaatst. Indien de gebruiker terug wenst te gaan wordt de bovenste route terug verwijderd van de stack en komt de gebruiker op de vorige pagina terecht.

De tweede aanpak is een iets gecompliceerdere aanpak. Deze volgt geen logische volgorde maar wel de volgorde die vastgelegd is door de ontwikkelaar. De aanpak berust op een Navigator.pages object. Hieraan kunnen de verschillende pagina's toegevoegd worden. Vervolgens zal de Navigator dit Navigator.pages object omzetten in een stack van routes. Indien een nieuwe pagina wordt toegevoegd aan Navigator.pages dan wordt de stack ook geüpdate. 

\begin{figure}
    \includegraphics[width=\linewidth]{NamedRoutesFlutter.png}
    \caption{Opzetten navigatie met benoemde routes in Flutter. Bron: \textcite{Flutter.dev2020}}
    \label{fig:namedRoutesFlutter}
\end{figure}

\begin{figure}
    \includegraphics[width=0.5\linewidth]{UseNamedRouteFlutter.png}
    \caption{Benoemde route tonen in Flutter. Bron: \textcite{Flutter.dev2020}}
    \label{fig:useNamedRoutesFlutter}
\end{figure}

Een applicatie kan uit zeer veel verschillende schermen bestaan. Om de navigatie ertussen overzichtelijk te houden voor de ontwikkelaar beschikt Flutter over een functie om de routes een naam te geven. Vervolgens kan de pagina aan de hand van zijn naam getoond worden. In figuur \ref{fig:namedRoutesFlutter} is de definitie van een map te zien die de naam van een route bevat en de builder die de route effectief zal tonen op het scherm. In figuur \ref{fig:useNamedRoutesFlutter} is te zien hoe de route effectief getoond kan worden. Uit de naam van de methode wordt duidelijk dat ook deze methode gebruik maakt van een stack voor de navigatie. De nieuwe route wordt bovenop de stack geplaatst.

Beide methodes maken dus gebruik van dezelfde stack en kunnen dus ook door elkaar gebruikt worden. Dit is een logische aanpak, aangezien een logische volgorde in een applicatie absoluut noodzakelijk is. Indien een gebruiker terug wil gaan is het alleen logisch om naar de vorige stap te gaan, ongeacht welke methode gebruikt werd om naar de huidige pagina te navigeren. 

Verder is het in Flutter mogelijk om een route een waarde te laten terug geven. Dit is bijvoorbeeld handig indien de gebruiker op oké moet klikken alvorens er naar het volgende scherm gegaan kan worden. Indien de gebruiker uit dit scherm gaat door de terug knop van het systeem te gebruiken is de waarde die teruggegeven wordt null en zal het volgende scherm dus niet getoond worden.

Tot slot geeft de Navigator klasse de ontwikkelaar ook de mogelijkheid om popups te tonen op het scherm. Dit zijn schermen die niet de volledig oppervlakte van het scherm in nemen en dus nog een deel van het onderliggende scherm tonen. Het onderliggende scherm wordt echter geblokkeerd, de gebruiker kan dus enkel binnen de popup input geven. Deze popups gedragen zich verder als een normale route, de navigatie naar een popup en er weg van is dus exact hetzelfde.

\subsection{Vergelijking navigatie}
\label{subsubsec:vglNavigatie}

Beide frameworks hebben hun eigen techniek om de navigatie aan te pakken. Het grootste verschil tussen beiden is dat React Native gebruik maakt van een library, waar Flutter gebruik maakt van een widget. Dit verschil vloeit voort uit het fundamentele verschil in aanpak tussen beide frameworks. De oorzaak is dat React Native voor een heel groot deel door de community onderhouden wordt. Onder andere de library voor navigatie komt voort uit de community en zit dus niet standaard in React Native, waar dit bij Flutter wel standaard beschikbaar is.

Voor de volgorde van de navigatie bij te houden maken beide frameworks gebruik van een stack. Ze zijn dus beide in staat om terug te gaan naar de vorige pagina. Bij React Native moet elke pagina echter wel steeds benaamd worden om er naar toe te kunnen navigeren, waar het bij Flutter mogelijk is om op voorhand een vaste volgorde te definiëren.

In het gevoel voor de gebruiker is er echter geen verschil tussen beide frameworks. Beide frameworks leveren een navigatie af die overeen komt met de native navigatie. Verder kan de ontwikkelaar bij beide de overgang tussen de verschillende pagina's aanpassen om te voldoen aan de uitstraling die de app wilt geven. 

Er kan besloten worden dat er op het vlak van navigatie geen duidelijk beter framework is. Er is een verschil tussen de manier waarop de ontwikkelaar de navigatie implementeerd, maar voor de gebruiker heeft de navigatie met beide frameworks hetzelfde native gevoel.



