\chapter{\IfLanguageName{dutch}{Stand van zaken}{State of the art}}
\label{ch:stand-van-zaken}

% Tip: Begin elk hoofdstuk met een paragraaf inleiding die beschrijft hoe
% dit hoofdstuk past binnen het geheel van de bachelorproef. Geef in het
% bijzonder aan wat de link is met het vorige en volgende hoofdstuk.

% Pas na deze inleidende paragraaf komt de eerste sectiehoofding.

%Dit hoofdstuk bevat je literatuurstudie. De inhoud gaat verder op de inleiding, maar zal het onderwerp van de bachelorproef *diepgaand* uitspitten. De bedoeling is dat de lezer na lezing van dit hoofdstuk helemaal op de hoogte is van de huidige stand van zaken (state-of-the-art) in het onderzoeksdomein. Iemand die niet vertrouwd is met het onderwerp, weet nu voldoende om de rest van het verhaal te kunnen volgen, zonder dat die er nog andere informatie moet over opzoeken \autocite{Pollefliet2011}.

%Je verwijst bij elke bewering die je doet, vakterm die je introduceert, enz. naar je bronnen. In \LaTeX{} kan dat met het commando \texttt{$\backslash${textcite\{\}}} of \texttt{$\backslash${autocite\{\}}}. Als argument van het commando geef je de ``sleutel'' van een ``record'' in een bibliografische databank in het Bib\LaTeX{}-formaat (een tekstbestand). Als je expliciet naar de auteur verwijst in de zin, gebruik je \texttt{$\backslash${}textcite\{\}}.
%Soms wil je de auteur niet expliciet vernoemen, dan gebruik je \texttt{$\backslash${}autocite\{\}}. In de volgende paragraaf een voorbeeld van elk.

%\textcite{Knuth1998} schreef een van de standaardwerken over sorteer- en zoekalgoritmen. Experten zijn het erover eens dat cloud computing een interessante opportuniteit vormen, zowel voor gebruikers als voor dienstverleners op vlak van informatietechnologie~\autocite{Creeger2009}.
%
%\lipsum[7-20]

In dit hoofdstuk wordt de huidige stad van zaken binnen het domein van cross-platform frameworks besproken aan de hand van een literatuurstudie. Er wordt begonnen met een algemene uitleg van een cross-platform framework, met alle voor- en nadelen ten opzichte van een native framework. Hierbij worden ook de verschillende soorten cross-platform frameworks besproken. Vervolgens zullen de drie afzonderlijke frameworks van nader bij bekeken worden: hun voor- en nadelen, achtergrond en toekomstvisie. Dit gebeurd zonder een onderlinge vergelijking te maken, deze is pas voor later in dit onderzoek. 

\section{Wat is een cross-platform framework?}

 Volgens \textcite{El-Kassas2014} en zoals de naam al doet vermoeden is een cross-platform framework een framework dat de ontwikkelaar in staat stelt om een applicatie te laten werken op verschillende besturingssystemen met slecht één broncode. Dit zorgt ervoor dat applicaties op alle besturingssystemen tegelijk beschikbaar zijn en dat de benodigde tijd om dit te doen gevoelig daalt. Net zoals elke technologie zijn er natuurlijk ook bepaalde voor- en nadelen verbonden aan cross-platfrom frameworks. Deze zullen in de volgende paragrafen besproken worden.
 
\section{Voordelen van cross-platform frameworks}



\section{Nadelen van cross-platform frameworks}

\section{verschillende aanpakken tot cross-platform}
 
 In de studie van \textcite{Xanthopoulos2013} worden vier verschillende aanpakken van cross-platform ontwikkelen besproken:
 
 \begin{itemize}
     \item Webapplicaties
     \item Hybride applicaties
     \item Geïnterpreteerde applicaties
     \item Gegenereerde applicaties
 \end{itemize}

In de volgende secties worden de voor- en nadelen van de verschillende aanpakken kort besproken.

\subsection{Webapplicaties}

Webapplicaties zijn applicaties die draaien in een webbrowser. Het grote voordeel van dit soort applicaties is dat elk apparaat dat beschik over een webbrowser toegang heeft tot de applicatie. Het is dus meteen duidelijk dat de applicatie slechts één keer geschreven hoeft te worden. Er is echter ook een groot nadeel verbonden aan het werken met webapplicaties: doordat ze draaien in een webbrowser heeft de applicatie geen toegang tot de interne hardware mogelijkheden van het apparaat. Een ander nadeel is dat de gebruiker steeds internettoegang nodig heeft om de applicatie te kunnen gebruiken: offline toegang is geen optie!

\subsection{Hybride applicaties}

Zoals de naam al doet vermoeden zijn hybride applicaties een combinatie van twee technologieën: ze combineren de gemakkelijkheid van webapplicaties (het werken met Html5 en Javascript) met de mogelijkheden van native applicaties. Dit houdt in dat de ontwikkelaar geen specifieke kennis nodig heeft van de besturingssystemen waarop de applicatie zal draaien maar dat de applicatie wel toegang heeft tot de interne hardware van het doelsysteeem (zoals o.a. de camera). 

\subsection{Geïnterpreteerde applicaties}

Bij geïnterpreteerde applicaties wordt er tijdens het ontwikkelen gebruik gemaakt van een framework dat de gebruikersinterface beschrijft aan de hand van eigen componenten. Bij het effectieve gebruiken van de app op een bepaald systeem wordt deze beschrijving automatisch omgezet naar native code, zodat de app een native uitstraling krijgt. Hieruit volgt zowel het grootste voordeel als nadeel. De gebruikers hebben het gevoel van een native applicatie te gebruiken, wat een grote invloed heeft op de gebruikservaring. Anderzijds is het omzetten van de beschrijving van de gebruikersinterface volledig platform afhankelijk: indien er een update wordt uitgebracht van een bepaald platform kunnen de nieuwe kenmerken hiervan pas gebruikt worden als ook het framework hiervoor is geüpdate. Als de gebruiker dus een update ontvangt van zijn besturingssysteem zal de interface van de applicatie niet direct mee geüpdate worden.

\subsection{Gegenereerde applicaties}

Gegenereerde applicaties lijken heel sterk op geïnterpreteerde applicaties. Het grootste verschil is dat hier voor elk platform effectief een volledig aparte applicatie wordt gegenereerd op basis van de abstracte beschrijving die de ontwikkelaar heeft gemaakt, waar dit bij geïnterpreteerde applicaties enkel de gebruikersinterface betreft en het dus geen aparte applicaties zijn. Dit soort applicaties hebben een zeer goede performantie doordat het eigenlijk native applicaties zijn. Een nadeel voor de ontwikkelaar is dat het debuggen een pak moeilijker wordt. Aangezien de code tijdens het compilen wordt omgezet naar native code moet de ontwikkelaar vertrouwd zijn met deze native code om te kunnen gaan kijken waar de bug zit.



