%---------- Inleiding ---------------------------------------------------------

\section{Introductie} % The \section*{} command stops section numbering
\label{sec:introductie}

In de wereld van vandaag beschikt bijna iedereen over een smartphone. Om deze apparaten ten volle te kunnen benutten zijn er miljoenen applicaties beschikbaar die op hun beurt kunnen rekenen op miljoenen gebruikers. Om aan de steeds groter wordende verwachtingen van de gebruikers te voldoen spenderen ontwikkelaars zeer veel tijd aan het bouwen van nieuwe applicaties en het onderhouden en verbeteren van reeds bestaande applicaties. Bij het ontwikkelen van mobiele applicaties komen ontwikkelaars steeds weer dezelfde uitdaging tegen: op dit moment zijn er twee populaire besturingssystemen waarop deze applicaties moeten kunnen werken voor mobiele gebruikers, zijnde iOS en Android. Aangezien ontwikkelaars natuurlijk niet op voorhand reeds een heel groot percentage potentiële gebruikers willen uitsluiten moeten alle applicaties ontwikkeld worden voor beide besturingssystemen. Dit is een tijdrovend en repititief proces, aangezien er in se twee keer hetzelfde gemaakt wordt. Om dit probleem aan te pakken zijn cross-platform frameworks in het leven geroepen. Dit zijn frameworks die de ontwikkelaar in staat stellen om met één enkele broncode hun applicatie te laten werken op verschillende besturingssystemen. Dit levert een grote tijdswinst op voor de ontwikkelaar en is dus een zeer interessante technologie om mee aan de slag te gaan. De laatste jaren zijn meer en meer productenten van frameworks zich hier ook op gaan focussen met als gevolg dat er nu een brede keuze is aan verschillende cross platform frameworks. De vraag dringt zich dus op welke van deze bestaande frameworks de beste keuze is om in de toekomst mee aan de slag te gaan voor het ontwikkelen van mobiele applicaties. In deze studie zullen drie cross platform frameworks van grote producenten met elkaar vergeleken worden: React Native (Facebook), Blazor en MAUI (beiden Microsoft). Concreet zal er gewerkt worden rond de volgende onderzoeksvraag: welk cross platform framework is de beste keuze voor een team van ontwikkelaars om de komende jaren op in te zetten voor het ontwikkelen van mobiele applicaties. Hierbij zal gekeken worden naar de gebruiksvriendelijkheid voor zowel de ontwikkelaar als de gebruiker, de ondersteuning van het framework, de snelheid van apps ontwikkeld met dit framework en de veiligheid van het framework. Van elke technologie zullen de sterke en zwakke punten opgesomd worden, ze zullen onderling vergeleken worden op de hiervoor benoemde punten en in de conclusie zal een aanbeveling gedaan worden welk framework het meest 'future-proof' is. 
%---------- Stand van zaken ---------------------------------------------------

\section{Literatuurstudie}
\label{sec:literatuurstudie}

Alvorens er dieper kan ingegaan worden op de specifieke frameworks is het belangrijk om te weten wat een cross platform framework is en wat de voor- en nadelen zijn ten opzichte van een klassiek native framework. Zo wordt ook meteen duidelijk wat al deze frameworks gemeenschappelijk hebben, zodat het vervolgens makkelijker zal zijn om de verschillen te gaan bekijken.

\subsection{Definitie van cross platform frameworks}

Volgens \textcite{El-Kassas2014} en zoals de naam al doet vermoeden is een cross platform framework een framework dat de ontxwikkelaar in staat stelt om een applicatie te laten werken op verschillende besturingssystemen. Dit zorgt ervoor dat applicaties op alle besturingssystemen tegelijk beschikbaar zijn en dat de benodigde tijd om dit te doen gevoelig daalt. Dit levert dus een groot voordeel op voor de ontwikkelaars zelf, maar ook voor de gebruikers van de applicatie zijn er zeker enkele voordelen aan verbonden. Net zoals elke technologie zijn er natuurlijk ook bepaalde nadelen verbonden aan cross platfrom frameworks. Zowel de voordelen als de nadelen zullen in de volgende paragrafen besproken worden.

\subsection{Voordelen van cross platform frameworks}

Er zijn vele voordelen verbonden aan cross platform frameworks, zowel voor de ontwikkelaars als voor de gebruikers van de applicatie. De meeste van deze voordelen komen rechtstreeks voort uit het feit dat er slecht één broncode moet geschreven worden. Ten eerste levert het schrijven van één broncode een enorme tijdswinst op voor de ontwikkelaars. Indien een bepaalde applicatie voor twee verschillende besturingssystemen geschreven moet worden zal ofwel één team er dubbel zo lang over doen of zal er een dubbel zo groot team nodig zijn om allebei de applicaties tegelijk te maken. Door deze beide situaties te voorkomen wordt er een zeer grote kost uitgespaard. Ook de tijd om de applicatie op de markt te brengen daalt gevoelig. Hierdoor wordt een voordeel op de concurentie behaald die misschien aan een gelijkaardige applicatie aan het werken zijn. Verder heeft dit niet enkel een voordeel op het ontwikkelen van nieuwe applicaties maar ook op het onderhouden en updaten van reeds bestaande applicaties. Bugs moeten slechts één keer opgelost worden en ook nieuwe features hoeven slechts één keer ontwikkeld te worden om op alle besturingssystemen beschikbaar te zijn. Dit leidt tot een groot voordeel voor de gebruikers, die sneller kunnen beschikken over applicaties waarin de foutjes zijn opgelost en waaraan nieuwe features zijn toegevoegd. Ook de connectie met de cloud en andere externe services wordt vereenvoudigd door een enkelvoudige broncode: er is slechts één code die steunt op deze externe services. Hierdoor is dit makkelijker op te zetten en te onderhouden.

Verder bereikt men door een applicatie te ontwikkelen die werkt op alle besturingssystemen wordt een groter doelpubliek met de applicatie. Niet iedereen heeft nu eenmaal een smartphone die werkt op hetzelfde besturingssysteem. Indien men dus een applicatie zou uitbrengen die enkel werkt op Android of iOS verliest men direct een groot deel mogelijke gebruikers. Zelfs als er een nieuw populair besturingssysteem zou bijkomen voor smarpthones is dit geen probleem, de applicatie zal ook op dit besturingssysteem kunnen werken.

Tot slot heeft het ontwikkelen van één enkele applicatie nog een extra voordeel voor de gebruiker: indien deze overschakelt naar een nieuw besturingssysteem zal hij nog steeds beroep kunnen doen op zijn vertrouwde applicaties. Er is zelfs nog meer: de layout van de applicaties zal identiek het zelfde zijn, aangezien het om één en dezelfde applicatie gaat (mist enkele minieme verschillen eigen aan de verschillende besturingssystemen). Hierdoor moet de gebruiker niet wennen aan een nieuwe layout en stijgt de gebruiksvriendelijkheid en herkenbaarheid.

Deze 3 stappen zijn zeer belangrijk: naarmate een applicatie groter wordt zal ook de test suite (de verzamelig van alle testen) zeer groot worden. Deze kunnen niet allemaal steeds opnieuw uitgevoerd worden (dit zou veel te lang duren en dus ook te veel geld kosten). Er wordt dus telkens slechts een deel van de beschikbare test cases uitgevoerd. De testen moeten echter wel nog steeds zekerheid geven dat de code geen fouten bevat. Het is dus essentieel om een goede selectie van test cases te maken. 

Volgens \textcite{PrashantMalangave2015} is de beste manier om aan 'Test prioritization' te doen kijken naar de code coverage (hoeveel procent van de code effectief getest wordt door deze test). Uit de geselecteerde test cases is de beste strategie om eerst deze met de grootste code coverage te gaan kiezen doordat er meer fouten gevonden kunnen worden als er meer code getest wordt.

\subsection{Combinatorial interaction regression test (CIT)}

Een mogelijke oplossing voor het verkleinen van het aantal test cases dat gebruikt moet worden is volgens \textcite{Qu2014} Combinatorial interaction testing (CIT). Dit is een techniek die gebruik maakt van parameter interacties om fouten te ontdekken, waardoor ook de interactie tussen verschillende compononenten van het systeem behandeld wordt \autocite{Brcic2013}.

% Voor literatuurverwijzingen zijn er twee belangrijke commando's:
% \autocite{KEY} => (Auteur, jBij het aartal) Gebruik dit als de naam van de auteur
%   geen onderdeel is van de zin.
% \textcite{KEY} => Auteur (jaartal)  Gebruik dit als de auteursnaam wel een
%   functie heeft in de zin (bv. ``Uit onderzoek door Doll & Hill (1954) bleek
%   ...'')

%---------- Methodologie ------------------------------------------------------
\section{Methodologie}
\label{sec:methodologie}

Om een goed beeld te krijgen van de reeds bestaande oplossingen voor regressietesten zal er eerst hierover een grondige tudie gevoerd worden. Vervolgens zal er een grondige studie gedaan worden naar de werking van chatbots. Na afloop van beide studies zal er bekeken worden hoe de bestaande oplossingen voor regressietesten geïmplementeerd kunnen worden om regressietesten voor chatbots te gaan ontwikkelen. Om te testen of de aangewezen methodes voor het schrijven van regressietesten effectief bruikbaar zijn bij het testen van chatbots zal er een test case uitgewerkt worden. Aan de hand van de resultaten van deze test case kan er vervolgens bepaald worden of deze methodes effectief een meerwaarde bieden. Voor de gebruiksvriendelijkheid van de methode te testen zal er een klein experiment uitgevoerd worden bij Clever en achteraf een vragenlijst. Op deze manier kan bepaald worden of de voorgestelde methode effectief bruikbaar is en een meerwaarde zal kunnen bieden in de toekomst. 


%---------- Verwachte resultaten ----------------------------------------------
\section{Verwachte resultaten}
\label{sec:verwachte_resultaten}

De lijn van verwachting voor dit onderzoek is dat er een concreet voorstel zal uit voortvloeien om met een bepaalde methode aan de slag te gaan. De kans is echter groot dat er op dit moment nog geen framework beschikbaar is dat helemaal zal voldoen aan de noden van Clever. Gezien het feit dat het ontwikkelen van een test framework niet hoort tot de scope van dit onderzoek zal er in dit geval geen kant en klare oplossing zijn. Wel kan het resultaat van dit onderzoek leiden tot een beter inzicht van hoe er aan de slag kan gegaan worden met de reeds bestaande frameworks.

%---------- Verwachte conclusies ----------------------------------------------
\section{Verwachte conclusies}
\label{sec:verwachte_conclusies}

De verwachte conclusie is dat het schrijven van regressietesten voor chatbots geen sinecure is. Door de enorme hoeveelheid mogelijke input zal nooit de volledige chatbot telkens opnieuw getest kunnen worden. Wat wel mogelijk zal blijken is dat de taalherkenning en de meest voorkomende vragen die de chatbot zal moeten beantwoorden getest zullen kunnen worden. Een aanrading van een framework zal er waarschijnlijk wel inzitten, maar een proof of concept opleveren zal alleen lukken indien er een gratis framework beschikbaar is. Een laatste conclusie zal echter zijn dat het testen van chatbots een tijdsintensieve gebeurtenis zal blijven en dat er nog zeer veel ruimte zal zijn voor verbetering op het vlak van gebruiksvriendelijkheid.

